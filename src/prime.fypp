#:set integer_kinds = ['i32', 'i64']
module prime_m

    use constant_m
    use utility_m, only: sqrt
    implicit none
    private

    public :: is_prime
    public :: Sieve_of_Eratosthenes

    !> A generic interface that tells if an integer is prime.
    interface is_prime
        #: for kind in integer_kinds
        module procedure is_prime_${kind}$
        #: endfor
    end interface is_prime

    !> An algorithm for finding all prime numbers within a limit.
    interface Sieve_of_Eratosthenes
        #: for kind in integer_kinds
        module procedure Sieve_of_Eratosthenes_logical_${kind}$
        module procedure Sieve_of_Eratosthenes_${kind}$
        #: endfor
    end interface Sieve_of_Eratosthenes

contains

    #: for kind in integer_kinds
    !> ${kind}$ version of 'is_prime'
    elemental logical function is_prime_${kind}$ (n)
        integer(${kind}$), intent(in) :: n
        integer(${kind}$) :: i

        is_prime_${kind}$ = .true.
        select case (n)
        case (0_${kind}$, 1_${kind}$)
            is_prime_${kind}$ = .false.
            return
        case (2_${kind}$, 3_${kind}$)
            return
        end select

        if (mod(n, 2_${kind}$) == 0_${kind}$) then
            is_prime_${kind}$ = .false.
            return
        end if

        do i = 3_${kind}$, sqrt(n) + 1_${kind}$, 2_${kind}$
            if (mod(n, i) == 0_${kind}$) then
                is_prime_${kind}$ = .false.
                return
            end if
        end do
    end function is_prime_${kind + "\n"}$
    #: endfor

    #: for kind in integer_kinds
    !> ${kind}$ version of 'Sieve_of_Eratosthenes_logical'
    pure subroutine Sieve_of_Eratosthenes_logical_${kind}$ (n, primes)
        integer(${kind}$), intent(in) :: n
        logical, intent(out) :: primes(n)
        integer(${kind}$) :: i

        primes = [[.false., .true.], [(mod(i, 2_${kind}$) /= 0_${kind}$, i=3_${kind}$, n)]]
        do i = 2_${kind}$, sqrt(n)
            if (primes(i)) primes(i*i:n:i) = .false.
        end do
    end subroutine Sieve_of_Eratosthenes_logical_${kind + "\n"}$
    #: endfor

    #: for kind in integer_kinds
    !> ${kind}$ version of 'Sieve_of_Eratosthenes'
    pure subroutine Sieve_of_Eratosthenes_${kind}$ (n, primes)
        integer(${kind}$), intent(in) :: n
        integer(${kind}$), allocatable, intent(out) :: primes(:)
        logical :: is_primes(n)
        integer(${kind}$) :: i

        call Sieve_of_Eratosthenes(n, is_primes)
        primes = pack([(i, i=1_${kind}$, n)], is_primes)
    end subroutine Sieve_of_Eratosthenes_${kind + "\n"}$
    #: endfor

end module prime_m
