#: include 'Common.fypp'
submodule(long_integer_module) long_integer_submodule

  implicit none
  !> Inner function ends with a '_'.

contains

  !> Re-allocate a long_integer with length n.
  pure subroutine allocate_(val, n)
    type(long_integer), intent(inout) :: val
    integer(i32), intent(in) :: n

    if (allocated(val%digit)) then
      if (size(val%digit) /= n) then
        deallocate (val%digit)
        allocate (val%digit(n))
      end if
    else
      allocate (val%digit(n))
    end if
  end subroutine allocate_

  !> Cut leading zeros of an digit array.
  pure function cut_leading_zeros_(digs) result(ret)
    integer(i8), contiguous, intent(in) :: digs(:)
    integer(i8), allocatable :: ret(:)
    integer(i32) :: i

    do i = 1, size(digs)
      if (digs(i) /= 0_i8) then
        ret = digs(i:)
        return
      end if
    end do
  end function cut_leading_zeros_

  !> The function of carry.
  pure function carry_(digs, opt) result(ret)
    integer(i8), contiguous, intent(in) :: digs(:)
    character, intent(in) :: opt
    integer(i8), allocatable :: ret(:)
    integer(i8), allocatable :: tmp(:)

    select case (opt)
    case ('+')
      ret = [[0_i8], digs]
      allocate (tmp(size(ret)))

      do while (any(ret >= 10))
        tmp = merge(1, 0, ret >= 10)
        where (ret >= 10) ret = ret - 10
        ret = ret + cshift(tmp, 1)
      end do
    case ('-')
      ret = digs
      allocate (tmp(size(ret)))

      do while (any(ret < 0))
        tmp = merge(1, 0, ret < 0)
        where (ret < 0) ret = ret + 10
        ret = ret - cshift(tmp, 1)
      end do
    case default
      error stop "Error: carry_."
    end select
  end function carry_

  !> Inner function used in add_ and sub_
  pure subroutine init_(dig1, dig2, tmp1, tmp2)
    integer(i8), contiguous, intent(in) :: dig1(:), dig2(:)
    integer(i8), allocatable, intent(out) :: tmp1(:), tmp2(:)
    integer(i32) :: i, n

    associate (n1 => size(dig1), n2 => size(dig2))
      n = max(n1, n2)
      tmp1 = [[(0_i8, i=1, n - n1)], dig1]
      tmp2 = [[(0_i8, i=1, n - n2)], dig2]
    end associate
  end subroutine init_

  !> Inner function to add two positive digit arrays.
  pure function add_(dig1, dig2) result(ret)
    integer(i8), contiguous, intent(in) :: dig1(:), dig2(:)
    integer(i8), allocatable :: ret(:)
    integer(i8), allocatable :: tmp1(:), tmp2(:)

    call init_(dig1, dig2, tmp1, tmp2)
    ret = cut_leading_zeros_(carry_(tmp1 + tmp2, '+'))
  end function add_

  !> Inner function to subtract when dig2 >= dig1.
  pure function sub_(dig2, dig1) result(ret)
    integer(i8), contiguous, intent(in) :: dig2(:), dig1(:)
    integer(i8), allocatable :: ret(:)
    integer(i8), allocatable :: tmp1(:), tmp2(:)

    call init_(dig1, dig2, tmp1, tmp2)
    ret = cut_leading_zeros_(carry_(tmp2 - tmp1, '-'))
  end function sub_

  !> Inner function to compare two digit arrays.
  pure function comp_(dig1, dig2) result(ret)
    integer(i8), contiguous, intent(in) :: dig1(:), dig2(:)
    integer(i8) :: ret
    integer(i32) :: i, n1, n2

    n1 = size(dig1)
    n2 = size(dig2)

    if (n1 > n2) then
      ret = 1
      return
    else if (n1 < n2) then
      ret = -1
      return
    end if

    do i = n1, 1, -1
      if (dig1(i) > dig2(i)) then
        ret = 1
        return
      else if (dig1(i) < dig2(i)) then
        ret = -1
        return
      else
        ret = 0
      end if
    end do

    if (ret /= 0) then
      error stop 'Error: comp_'
    end if
  end function comp_

  !> Initialize a long_integer with an integer.
  pure module subroutine init_i32(val1, val2)
    type(long_integer), intent(inout) :: val1
    integer(i32), intent(in) :: val2
    integer(i32) :: tmp, i
    integer(i32) :: num_digits

    val1%sign = merge("+", "-", val2 >= 0)
    if (val2 == 0_i32) then
      val1%digit = [0_i8]
      return
    end if

    tmp = abs(val2)
    num_digits = floor(log10(real(tmp))) + 1
    call allocate_(val1, num_digits)
    do i = num_digits, 1, -1
      val1%digit(i) = int(mod(tmp, 10), i8)
      tmp = tmp/10
    end do
  end subroutine init_i32

  !> Initialize a long_integer with a character.
  pure module subroutine init_str(val1, val2)
    type(long_integer), intent(inout) :: val1
    character(len=*), intent(in) :: val2

    select case (val2(1:1))
    case ("+", "-")
      val1%sign = val2(1:1)
      call allocate_(val1, len(val2) - 1)
      read (val2(2:len(val2)), "(*(i1))") val1%digit
    case default
      val1%sign = "+"
      call allocate_(val1, len(val2))
      read (val2(1:len(val2)), "(*(i1))") val1%digit
    end select
  end subroutine init_str

  !> Initialize a long_integer with i32_arr
  pure module subroutine init_i32_arr(val1, val2)
    type(long_integer), intent(inout) :: val1
    integer(i32), intent(in) :: val2(:)
    integer(i32) :: i

    call allocate_(val1, size(val2))
    if (any(val2 >= 10)) then
      error stop "Error: init_i32_arr."
    end if
    val1%sign = "+"
    val1%digit = [(int(val2(i), i8), i=1, size(val2))]
  end subroutine init_i32_arr

  !> Convert a variable to long integer
  elemental module function to_long_scal(val, kind) result(ret)
    class(*), intent(in) :: val
    character(*), intent(in) :: kind
    type(long_integer) :: ret

    select case(trim(kind))
    case ("ll", "long", "long_int", "long_integer")
    case default
      error stop "Error: to_long_scal."
    end select

    select type (val_ => val)
    type is (character(*))
      call init_str(ret, val_)
    type is (integer(i32))
      call init_i32(ret, val_)
    class default
      error stop "Error: to_long_scal."
    end select
  end function to_long_scal

  pure module function to_long_vect(vals, kind) result(ret)
    class(*), intent(in) :: vals(:)
    character(*), intent(in) :: kind
    type(long_integer) :: ret

    select case(trim(kind))
    case ("ll", "long", "long_int", "long_integer")
    case default
      error stop "Error: to_long_vect."
    end select

    select type (vals_ => vals)
    type is (integer(i32))
      call init_i32_arr(ret, vals_)
    class default
      error stop "Error: to_long_vect."
    end select
  end function to_long_vect

  !> Equal.
  elemental module logical function eq(val1, val2)
    type(long_integer), intent(in) :: val1, val2

    eq = all(val1%digit == val2%digit) &
         .and. val1%sign == val2%sign
  end function eq

  !> Greater than
  elemental module logical function gt(val1, val2)
    type(long_integer), intent(in) :: val1, val2
    logical :: pstv, ngtv
    integer(i8) :: c

    c = comp_(val1%digit, val2%digit)
    pstv = all([val1%sign, val2%sign] == "+")
    ngtv = all([val1%sign, val2%sign] == "-")
    gt = any([pstv .and. c == 1, ngtv .and. c == -1, &
              val1%sign == "+" .and. val2%sign == "-"])
  end function gt

  !> Less than
  elemental module logical function lt(val1, val2)
    type(long_integer), intent(in) :: val1, val2
    logical :: pstv, ngtv
    integer(i8) :: c

    c = comp_(val1%digit, val2%digit)
    pstv = all([val1%sign, val2%sign] == "+")
    ngtv = all([val1%sign, val2%sign] == "-")
    lt = any([pstv .and. c == -1, ngtv .and. c == 1, &
              val1%sign == "-" .and. val2%sign == "+"])
  end function lt

  !> Greater than or equal to.
  elemental module logical function ge(val1, val2)
    type(long_integer), intent(in) :: val1, val2

    ge = gt(val1, val2) .or. eq(val1, val2)
  end function ge

  !> Less than or equal to
  elemental module logical function le(val1, val2)
    type(long_integer), intent(in) :: val1, val2

    le = lt(val1, val2) .or. eq(val1, val2)
  end function le

  #: for func in rel_names
  #: for suffix, T in suffix_type_names
  !> Wrapper of function ${func}$ for type ${T}$
  pure module function ${func}$_${suffix}$ (val1, val2) result(ret)
    type(long_integer), intent(in) :: val1
    ${T}$, intent(in) :: val2
    logical :: ret

    ret = ${func}$(val1, int(val2, "ll"))
  end function ${func}$_${suffix}$ ${"\n"}$
  #: endfor
  #: endfor

  !> Addition.
  elemental module function add(val1, val2) result(ret)
    type(long_integer), intent(in) :: val1, val2
    type(long_integer) :: ret
    integer(i8) :: c

    c = comp_(val1%digit, val2%digit)
    if (c == 0 .and. val1%sign /= val2%sign) then
      ret%digit = [0_i8]
      ret%sign = "+"
    else if (val1%sign == "+" .and. val2%sign == "+") then
      ret%digit = add_(val1%digit, val2%digit)
      ret%sign = "+"
    else if (val1%sign == "-" .and. val2%sign == "-") then
      ret%digit = add_(val1%digit, val2%digit)
      ret%sign = "-"
    else if (val1%sign == "+" .and. val2%sign == "-") then
      if (c == 1) then
        ret%digit = sub_(val1%digit, val2%digit)
        ret%sign = "+"
      else
        ret%digit = sub_(val2%digit, val1%digit)
        ret%sign = "-"
      end if
    else if (val1%sign == "-" .and. val2%sign == "+") then
      if (c == 1) then
        ret%digit = sub_(val1%digit, val2%digit)
        ret%sign = "-"
      else
        ret%digit = sub_(val2%digit, val1%digit)
        ret%sign = "+"
      end if
    else
      error stop "Error: add."
    end if
  end function add

  !> Subtraction.
  elemental module function sub(val1, val2) result(ret)
    type(long_integer), intent(in) :: val1, val2
    type(long_integer) :: ret
    integer(i8) :: c

    c = comp_(val1%digit, val2%digit)
    if (val2 == val1) then
      ret%digit = [0_i8]
      ret%sign = "+"
    else if (val2%sign == "+" .and. val1%sign == "+") then
      if (c == 1) then
        ret%digit = sub_(val1%digit, val2%digit)
        ret%sign = "+"
      else
        ret%digit = sub_(val2%digit, val1%digit)
        ret%sign = "-"
      end if
    else if (val2%sign == "-" .and. val1%sign == "-") then
      if (c == 1) then
        ret%digit = sub_(val1%digit, val2%digit)
        ret%sign = "-"
      else
        ret%digit = sub_(val2%digit, val1%digit)
        ret%sign = "+"
      end if
    else if (val2%sign == "+" .and. val1%sign == "-") then
      ret%digit = add_(val2%digit, val1%digit)
      ret%sign = "+"
    else if (val2%sign == "-" .and. val1%sign == "+") then
      ret%digit = add_(val2%digit, val1%digit)
      ret%sign = "-"
    else
      error stop "Error: sub."
    end if
  end function sub

end submodule long_integer_submodule
