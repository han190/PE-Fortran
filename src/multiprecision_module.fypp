#: include 'common.fypp'
module multiprecision_module

  use constant_module, only: i32
  implicit none

  public :: long_integer
  public :: assignment(=)
  #: for op in rel_ops
  public :: operator(${op}$)
  #: endfor
  #: for op in add_ops
  public :: operator(${op}$)
  #: endfor
  public :: operator(*)
  public :: operator(**)
  public :: int

  private

  !> Long integer type.
  !> Assuming the number of digits
  !> is less than huge(0_i32).
  type :: long_integer
    character :: sign
    integer(i32), allocatable :: digit(:)
  end type long_integer

  !> Assignment
  interface assignment(=)
    #: for suffix in suffix_names
    module procedure init_${suffix}$
    #: endfor
  end interface assignment(=)

  !> Overloaded intrinsics
  interface int
    module procedure to_long_scal
    module procedure to_long_vect
  end interface int

  !> rel-ops
  #: for op, func in rel_opnames
  interface operator(${op}$)
    module procedure ${func}$
    #: for suffix in suffix_names
    module procedure ${func}$_${suffix}$
    #: endfor
  end interface operator(${op}$) ${"\n"}$
  #: endfor

  !> add-ops
  #: for op, func in add_opnames
  interface operator(${op}$)
    module procedure ${func}$
    #: for suffix in suffix_names
    module procedure ${func}$_${suffix}$
    #: endfor
  end interface operator(${op}$) ${"\n"}$
  #: endfor

  !> mul-ops
  interface operator(*)
    module procedure mul
    #: for suffix in suffix_names
    module procedure mul_${suffix}$
    #: endfor
  end interface operator(*)

  !> power-op
  interface operator(**)
    module procedure pow
  end interface operator(**)

  !> Interfaces for submodule
  interface
    #: for suffix, T in suffix_type_names
    pure module subroutine init_${suffix}$(val1, val2)
      type(long_integer), intent(inout) :: val1
      ${T}$, intent(in) :: val2
    end subroutine init_${suffix}$ ${"\n"}$
    #: endfor

    elemental module function to_long_scal(val, kind) result(ret)
      class(*), intent(in) :: val
      character(*), intent(in) :: kind
      type(long_integer) :: ret
    end function to_long_scal

    pure module function to_long_vect(vals, kind) result(ret)
      class(*), intent(in) :: vals(:)
      character(*), intent(in) :: kind
      type(long_integer) :: ret
    end function to_long_vect

    #: for func in rel_names
    elemental module logical function ${func}$(val1, val2)
      type(long_integer), intent(in) :: val1, val2
    end function ${func}$ ${"\n"}$
    #: endfor

    #: for func in rel_names
    #: for suffix, T in suffix_type_names
    pure module function ${func}$_${suffix}$(val1, val2) result(ret)
      type(long_integer), intent(in) :: val1
      ${T}$, intent(in) :: val2
      logical :: ret
    end function ${func}$_${suffix}$ ${"\n"}$
    #: endfor
    #: endfor

    #: for func in add_names
    elemental module function ${func}$(val1, val2) result(ret)
      type(long_integer), intent(in) :: val1, val2
      type(long_integer) :: ret
    end function ${func}$ ${"\n"}$
    #: endfor

    elemental module function mul(val1, val2) result(ret)
      type(long_integer), intent(in) :: val1, val2
      type(long_integer) :: ret
    end function mul

    elemental recursive module function pow(val1, val2) result(ret)
      type(long_integer), intent(in) :: val1
      integer(i32), intent(in) :: val2
      type(long_integer) :: ret
    end function pow

    #: for func in ['add', 'sub', 'mul']
    #: for suffix, T in suffix_type_names
    pure module function ${func}$_${suffix}$(val1, val2) result(ret)
      type(long_integer), intent(in) :: val1
      ${T}$, intent(in) :: val2
      type(long_integer) :: ret
    end function ${func}$_${suffix}$ ${"\n"}$
    #: endfor
    #: endfor
  end interface

end module multiprecision_module
