#:set integer_kinds = ['i32', 'i64']
module prime_module

  use constant_module, only: i32, i64
  use utility_module, only: sqrt
  implicit none

  public :: is_prime
  public :: Sieve_of_Eratosthenes
  public :: number_of_divisors
  public :: prime_factorization

  private

  !> A generic interface that tells if an integer is prime.
  interface is_prime
    #: for kind in integer_kinds
    module procedure is_prime_${kind}$
    #: endfor
  end interface is_prime

  !> An algorithm for finding all prime numbers within a limit.
  interface Sieve_of_Eratosthenes
    #: for kind in integer_kinds
    module procedure Sieve_of_Eratosthenes_logical_${kind}$
    module procedure Sieve_of_Eratosthenes_${kind}$
    #: endfor
  end interface Sieve_of_Eratosthenes

  !> Prime factorization.
  interface prime_factorization
    #: for kind in integer_kinds
    module procedure prime_factorization_${kind}$
    #: endfor
  end interface prime_factorization

  !> Number of divisors.
  interface number_of_divisors
    #: for kind in integer_kinds
    module procedure number_of_divisors_${kind}$
    #: endfor
  end interface number_of_divisors

contains

  #: for kind in integer_kinds
  !> ${kind}$ version of 'is_prime'
  elemental logical function is_prime_${kind}$ (n)
    integer(${kind}$), intent(in) :: n
    integer(${kind}$) :: i

    is_prime_${kind}$ = .true.
    select case (n)
    case (0_${kind}$, 1_${kind}$)
      is_prime_${kind}$ = .false.
      return
    case (2_${kind}$, 3_${kind}$)
      return
    end select

    if (mod(n, 2_${kind}$) == 0_${kind}$) then
      is_prime_${kind}$ = .false.
      return
    end if

    do i = 3_${kind}$, sqrt(n) + 1_${kind}$, 2_${kind}$
      if (mod(n, i) == 0_${kind}$) then
        is_prime_${kind}$ = .false.
        return
      end if
    end do
  end function is_prime_${kind}$${"\n"}$
  #: endfor

  #: for kind in integer_kinds
  !> ${kind}$ version of 'Sieve_of_Eratosthenes_logical'
  pure subroutine Sieve_of_Eratosthenes_logical_${kind}$ (n, primes)
    integer(${kind}$), intent(in) :: n
    logical, intent(out) :: primes(n)
    integer(${kind}$) :: i

    primes = [[.false., .true.], [(mod(i, 2_${kind}$) /= 0_${kind}$, i=3_${kind}$, n)]]
    do i = 2_${kind}$, sqrt(n)
      if (primes(i)) primes(i*i:n:i) = .false.
    end do
  end subroutine Sieve_of_Eratosthenes_logical_${kind}$${"\n"}$
  #: endfor

  #: for kind in integer_kinds
  !> ${kind}$ version of 'Sieve_of_Eratosthenes'
  pure subroutine Sieve_of_Eratosthenes_${kind}$ (n, primes)
    integer(${kind}$), intent(in) :: n
    integer(${kind}$), allocatable, intent(out) :: primes(:)
    logical :: is_primes(n)
    integer(${kind}$) :: i

    call Sieve_of_Eratosthenes(n, is_primes)
    primes = pack([(i, i=1_${kind}$, n)], is_primes)
  end subroutine Sieve_of_Eratosthenes_${kind}$${"\n"}$
  #: endfor

  #: for kind in integer_kinds
  !> Prime factorization of an ${kind}$ integer.
  pure subroutine prime_factorization_${kind}$ (n, primes, powers)
    integer(${kind}$), intent(in) :: n, primes(:)
    integer(${kind}$), intent(out) :: powers(size(primes))
    integer(${kind}$) :: i, tmp

    tmp = n
    powers = 0_${kind}$
    outer: do i = 1_${kind}$, size(primes)
      inner: do
        if (mod(tmp, primes(i)) /= 0_${kind}$) then
          exit inner
        else if (tmp == 0_${kind}$) then
          exit outer
        end if

        powers(i) = powers(i) + 1_${kind}$
        tmp = tmp/primes(i)
      end do inner
    end do outer
  end subroutine prime_factorization_${kind}$${"\n"}$
  #: endfor

  #: for kind in integer_kinds
  !> Number of proper divisors of an ${kind}$ integer.
  pure integer(${kind}$) function number_of_divisors_${kind}$ (n, primes)
    integer(${kind}$), intent(in) :: n, primes(:)
    integer(${kind}$) :: powers(size(primes))

    call prime_factorization(n, primes, powers)
    number_of_divisors_${kind}$ = product(powers + 1)
  end function number_of_divisors_${kind}$${"\n"}$
  #: endfor

end module prime_module
