#: set integer_kinds = ['i32', 'i64']
#: set digit_funcs = ['unit_digit', 'number_of_digits', 'sqrt']
#: set array_funcs = ['to_array', 'to_integer']
#: set spec_funcs = ['is_palindromic', 'is_pandigital', 'lcm']
#: set prime_funcs = ['prime_factorization', 'number_of_divisors']
#: set funcs = digit_funcs + array_funcs + spec_funcs + prime_funcs
module utility_m

    use constant_m, only: sp, i32, i64
    implicit none
    private

    #: for func in funcs
        public :: ${func}$
    #: endfor
    public :: swap
    public :: permute

    #: for func in funcs
        !> Function: ${func}$
        interface ${func}$
            #: for kind in integer_kinds
                module procedure ${func}$_${kind}$
            #: endfor
        end interface ${func + "\n"}$
    #: endfor

    !> Swap.
    interface swap
        #: for kind in integer_kinds
            module procedure swap_${kind}$
        #: endfor
        module procedure swap_char
    end interface swap

    !> Next permutation.
    interface permute
        #: for kind in integer_kinds
            module procedure permute_${kind}$
            module procedure permute_kn_${kind}$
        #: endfor
    end interface permute

    !> Variant length array
    type, public :: variant_array_t
        integer(i32), allocatable :: array(:)
    end type variant_array_t

contains

    #: for kind in integer_kinds
        !> Unit digit of an ${kind}$ integer.
        elemental integer(${kind}$) function unit_digit_${kind}$ (n)
            integer(${kind}$), intent(in) :: n

            unit_digit_${kind}$ = mod(n, 10_${kind}$)
        end function unit_digit_${kind + "\n"}$
    #: endfor

    #: for kind in integer_kinds
        !> Number of digits in an ${kind}$ integer.
        elemental integer(${kind}$) function number_of_digits_${kind}$ (n)
            integer(${kind}$), intent(in) :: n

            number_of_digits_${kind}$ = floor(log10(real(n, sp))) + 1_${kind}$
        end function number_of_digits_${kind + "\n"}$
    #: endfor

    #: for kind in integer_kinds
        !> Next permutation (k, n) for ${kind}$.
        elemental integer(${kind}$) function sqrt_${kind}$ (n)
            integer(${kind}$), intent(in) :: n

            sqrt_${kind}$ = floor(sqrt(real(n, sp)), ${kind}$)
        end function sqrt_${kind + "\n"}$
    #: endfor

    #: for kind in integer_kinds
        !> Convert an integer into an ${kind}$ array.
        pure function to_array_${kind}$ (n) result(ret)
            integer(${kind}$), intent(in) :: n
            integer(${kind}$), allocatable :: ret(:)
            integer(${kind}$) :: i, temp

            temp = n
            associate (l => (number_of_digits(temp)))
                allocate (ret(l))
                do i = l, 1, -1
                    ret(i) = unit_digit(temp)
                    temp = temp/10_${kind}$
                end do
            end associate
        end function to_array_${kind + "\n"}$
    #: endfor

    #: for kind in integer_kinds
        !> Convert an ${kind}$ integer array into an ${kind}$ integer.
        pure integer(${kind}$) function to_integer_${kind}$ (arr)
            integer(${kind}$), intent(in) :: arr(:)
            integer(${kind}$) :: i, temp

            temp = 0_${kind}$
            do i = 1, size(arr)
                temp = temp*10_${kind}$+arr(i)
            end do
            to_integer_${kind}$ = temp
        end function to_integer_${kind + "\n"}$
    #: endfor

    #: for kind in integer_kinds
        !> To tell if an ${kind}$ integer is palindromic.
        elemental logical function is_palindromic_${kind}$ (n)
            integer(${kind}$), intent(in) :: n
            integer(${kind}$) :: reversed, temp

            reversed = 0_${kind}$
            temp = n
            do while (temp > 0_${kind}$)
                reversed = reversed*10_${kind}$+mod(temp, 10_${kind}$)
                temp = temp/10_${kind}$
            end do

            is_palindromic_${kind}$ = .false.
            if (n == reversed) is_palindromic_${kind}$ = .true.
        end function is_palindromic_${kind + "\n"}$
    #: endfor

    #: for kind in integer_kinds
        !> Prime factorization of an ${kind}$ integer.
        pure subroutine prime_factorization_${kind}$ (n, primes, powers)
            integer(${kind}$), intent(in) :: n, primes(:)
            integer(${kind}$), intent(out) :: powers(size(primes))
            integer(${kind}$) :: i, temp

            temp = n; powers = 0_${kind}$
            outer: do i = 1_${kind}$, size(primes)
                inner: do
                    if (mod(temp, primes(i)) /= 0_${kind}$) then
                        exit inner
                    else if (temp == 0_${kind}$) then
                        exit outer
                    end if

                    powers(i) = powers(i) + 1_${kind}$
                    temp = temp/primes(i)
                end do inner
            end do outer
        end subroutine prime_factorization_${kind + "\n"}$
    #: endfor

    #: for kind in integer_kinds
        !> Number of proper divisors of an ${kind}$ integer.
        pure integer(${kind}$) function number_of_divisors_${kind}$ (n, primes)
            integer(${kind}$), intent(in) :: n, primes(:)
            integer(${kind}$) :: powers(size(primes))

            call prime_factorization(n, primes, powers)
            number_of_divisors_${kind}$ = product(powers + 1)
        end function number_of_divisors_${kind + "\n"}$
    #: endfor

    #: for kind in integer_kinds
        !> To tell if an ${kind}$ integer is pandigital.
        pure logical function is_pandigital_${kind}$ (n)
            integer(${kind}$), intent(in) :: n
            integer(${kind}$) :: temp, l
            logical, allocatable :: array(:)

            l = number_of_digits(n)
            if (l > 9_${kind}$) l = 9_${kind}$
            allocate (array(l))

            is_pandigital_${kind}$ = .false.
            array = .false.
            temp = n

            do
                associate (u => (unit_digit(temp)))
                    if (u == 0_${kind}$ .or. u > l) exit
                    array(u) = .true.
                end associate
                temp = temp/10
            end do

            if (count(array) == l) is_pandigital_${kind}$ = .true.
        end function is_pandigital_${kind + "\n"}$
    #: endfor

    #: for kind in integer_kinds
        !> Least common multiple of two ${kind}$ integers.
        pure integer(${kind}$) function lcm_${kind}$ (a, b)
            use stdlib_math, only: gcd
            implicit none
            integer(${kind}$), intent(in) :: a, b

            lcm_${kind}$ = abs(a*b)/gcd(a, b)
        end function lcm_${kind + "\n"}$
    #: endfor

    #: for kind in integer_kinds
        !> Swap for ${kind}$.
        pure subroutine swap_${kind}$ (a, b)
            integer(${kind}$), intent(inout) :: a, b
            integer(${kind}$) :: temp

            temp = a; a = b; b = temp
        end subroutine swap_${kind + "\n"}$
    #: endfor

    pure subroutine swap_char(a, b)
        character(len=*), intent(inout) :: a
        character(len=len(a)), intent(inout) :: b
        character(len=len(a)) :: temp

        temp = a; a = b; b = temp
    end subroutine swap_char

    #: for kind in integer_kinds
        !> Next permutation of an ${kind}$ array.
        pure subroutine permute_${kind}$ (idx, next)
            integer(${kind}$), intent(inout) :: idx(:)
            logical, intent(out) :: next
            integer(${kind}$) :: i, j

            associate (s => (size(idx)))
                next = .false.
                do i = s - 1, 1, -1
                    if (idx(i) < idx(i + 1)) then
                        j = i
                        next = .true.
                        exit
                    end if
                end do
                if (.not. next) return

                do i = s, 1, -1
                    if (idx(j) < idx(i)) exit
                end do

                call swap_${kind}$ (idx(i), idx(j))
                idx(j + 1:s) = idx(s:j + 1:-1)
            end associate
        end subroutine permute_${kind + "\n"}$
    #: endfor

    #: for kind in integer_kinds
        !> Next permutation (k, n) of an ${kind}$ array.
        pure subroutine permute_kn_${kind}$ (n, idx, next)
            integer(${kind}$), intent(in) :: n
            integer(${kind}$), intent(inout) :: idx(:)
            logical, intent(out) :: next
            logical, allocatable :: carr(:)
            integer(${kind}$) :: i, x, k

            next = .true.
            k = size(idx)
            x = n - k + 1

            if (all(idx == [(i, i=x, n)])) then
                next = .false.; return
            end if

            carr = [(.true., i=1, k)]
            do i = k, 1, -1
                x = n - k + i
                if (idx(i) == x) carr(i) = .false.
            end do

            if (all(carr)) then
                idx(k) = idx(k) + 1; return
            end if

            x = findloc(carr, value=.false., dim=1) - 1
            idx(x:k) = idx(x) + [(i, i=1, k - x + 1)]
        end subroutine permute_kn_${kind + "\n"}$
    #: endfor

end module utility_m
