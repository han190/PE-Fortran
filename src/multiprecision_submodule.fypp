#: set rel_funcs = ['eq', 'gt', 'lt', 'ge', 'le']
#: set suffixes = ['str', 'i32', 'i32_arr']
#: set declares = ['character(*)', 'integer(i32)', 'integer(i32), dimension(:)']
submodule(multiprecision_module) multiprecision_submodule

  implicit none
  !> Inner function ends with a '_'.

contains

  !> Re-allocate a long_integer with length n.
  pure subroutine allocate_(val, n)
    type(long_integer), intent(inout) :: val
    integer(i32), intent(in) :: n

    if (allocated(val%digit)) then
      if (size(val%digit) /= n) then
        deallocate (val%digit)
        allocate (val%digit(n))
      end if
    else
      allocate (val%digit(n))
    end if
  end subroutine allocate_

  !> Cut leading zeros of an digit array.
  pure function cut_leading_zeros_(digs) result(ret)
    integer(i32), contiguous, intent(in) :: digs(:)
    integer(i32), allocatable :: ret(:)
    integer(i32) :: i

    do i = 1, size(digs)
      if (digs(i) /= 0) then
        ret = digs(i:)
        return
      end if
    end do
  end function cut_leading_zeros_

  !> The function of carry.
  pure function carry_(digs, opt) result(ret)
    integer(i32), contiguous, intent(in) :: digs(:)
    character, intent(in) :: opt
    integer(i32), allocatable :: ret(:)
    integer(i32), allocatable :: tmp(:)

    select case (opt)
    case ('+')
      ret = [[0], digs]
      allocate (tmp(size(ret)))

      do while (any(ret >= 10))
        tmp = merge(1, 0, ret >= 10)
        where (ret >= 10) ret = ret - 10
        ret = ret + cshift(tmp, 1)
      end do
    case ('-')
      ret = digs
      allocate (tmp(size(ret)))

      do while (any(ret < 0))
        tmp = merge(1, 0, ret < 0)
        where (ret < 0) ret = ret + 10
        ret = ret - cshift(tmp, 1)
      end do
    case default
      error stop "Error: carry_."
    end select
  end function carry_

  !> Inner function used in add_ and sub_
  pure subroutine init_(dig1, dig2, tmp1, tmp2)
    integer(i32), contiguous, intent(in) :: dig1(:), dig2(:)
    integer(i32), allocatable, intent(out) :: tmp1(:), tmp2(:)
    integer(i32) :: i, n

    associate (n1 => size(dig1), n2 => size(dig2))
      n = max(n1, n2)
      tmp1 = [[(0, i=1, n - n1)], dig1]
      tmp2 = [[(0, i=1, n - n2)], dig2]
    end associate
  end subroutine init_

  !> Inner function to add two positive digit arrays.
  pure function add_(dig1, dig2) result(ret)
    integer(i32), contiguous, intent(in) :: dig1(:), dig2(:)
    integer(i32), allocatable :: ret(:)
    integer(i32), allocatable :: tmp1(:), tmp2(:)

    call init_(dig1, dig2, tmp1, tmp2)
    ret = cut_leading_zeros_(carry_(tmp1 + tmp2, '+'))
  end function add_

  !> Inner function to subtract when dig2 >= dig1.
  pure function sub_(dig2, dig1) result(ret)
    integer(i32), contiguous, intent(in) :: dig2(:), dig1(:)
    integer(i32), allocatable :: ret(:)
    integer(i32), allocatable :: tmp1(:), tmp2(:)

    call init_(dig1, dig2, tmp1, tmp2)
    ret = cut_leading_zeros_(carry_(tmp2 - tmp1, '-'))
  end function sub_

  !> Inner function to compare two digit arrays.
  pure function comp_(dig1, dig2) result(ret)
    integer(i32), contiguous, intent(in) :: dig1(:), dig2(:)
    integer(i32) :: ret
    integer(i32) :: i, n1, n2

    n1 = size(dig1)
    n2 = size(dig2)

    if (n1 > n2) then
      ret = 1
      return
    else if (n1 < n2) then
      ret = -1
      return
    end if

    do i = n1, 1, -1
      if (dig1(i) > dig2(i)) then
        ret = 1
        return
      else if (dig1(i) < dig2(i)) then
        ret = -1
        return
      else
        ret = 0
      end if
    end do

    if (ret /= 0) then
      error stop 'Error: comp_'
    end if
  end function comp_

  !> Lattice multiplication
  pure function mul_(dig1, dig2) result(ret)
    integer(i32), intent(in) :: dig1(:), dig2(:)
    integer(i32), allocatable :: ret(:)
    integer(i32) :: i, j, tmp

    associate (n1 => size(dig1), n2 => size(dig2))
      allocate (ret(n1 + n2))
      ret = 0

      do concurrent (j=1:n2, i=1:n1)
        tmp = dig1(i)*dig2(j)
        ret(i + j) = ret(i + j) + mod(tmp, 10)
        ret(i + j - 1) = ret(i + j - 1) + tmp/10
      end do
    end associate
    ret = cut_leading_zeros_(carry_(ret, "+"))
  end function mul_

  !> Initialize a long_integer with an integer.
  pure module subroutine init_i32(val1, val2)
    type(long_integer), intent(inout) :: val1
    integer(i32), intent(in) :: val2
    integer(i32) :: tmp, i
    integer(i32) :: num_digits

    val1%sign = merge("+", "-", val2 >= 0)
    if (val2 == 0) then
      val1%digit = [0]
      return
    end if

    tmp = abs(val2)
    num_digits = floor(log10(real(tmp))) + 1
    call allocate_(val1, num_digits)
    do i = num_digits, 1, -1
      val1%digit(i) = int(mod(tmp, 10), i32)
      tmp = tmp/10
    end do
  end subroutine init_i32

  !> Initialize a long_integer with a character.
  pure module subroutine init_str(val1, val2)
    type(long_integer), intent(inout) :: val1
    character(len=*), intent(in) :: val2

    select case (val2(1:1))
    case ("+", "-")
      val1%sign = val2(1:1)
      call allocate_(val1, len(val2) - 1)
      read (val2(2:len(val2)), "(*(i1))") val1%digit
    case default
      val1%sign = "+"
      call allocate_(val1, len(val2))
      read (val2(1:len(val2)), "(*(i1))") val1%digit
    end select
  end subroutine init_str

  !> Initialize a long_integer with i32_arr
  pure module subroutine init_i32_arr(val1, val2)
    type(long_integer), intent(inout) :: val1
    integer(i32), intent(in) :: val2(:)
    integer(i32) :: i

    call allocate_(val1, size(val2))
    if (any(val2 >= 10)) &
      error stop "Error: init_i32_arr."
    val1%sign = "+"
    val1%digit = [(int(val2(i), i32), i=1, size(val2))]
  end subroutine init_i32_arr

  !> Convert a variable to long integer
  elemental module function to_long_scal(val, kind) result(ret)
    class(*), intent(in) :: val
    character(*), intent(in) :: kind
    type(long_integer) :: ret

    select case (trim(kind))
    case ("ll", "long", "long_int", "long_integer")
    case default
      error stop "Error: to_long_scal."
    end select

    select type (val_ => val)
    type is (character(*))
      call init_str(ret, val_)
    type is (integer(i32))
      call init_i32(ret, val_)
    class default
      error stop "Error: to_long_scal."
    end select
  end function to_long_scal

  !> Convert a variable array to long integer.
  pure module function to_long_vect(vals, kind) result(ret)
    class(*), intent(in) :: vals(:)
    character(*), intent(in) :: kind
    type(long_integer) :: ret

    select case (trim(kind))
    case ("ll", "long", "long_int", "long_integer")
    case default
      error stop "Error: to_long_vect."
    end select

    select type (vals_ => vals)
    type is (integer(i32))
      call init_i32_arr(ret, vals_)
    class default
      error stop "Error: to_long_vect."
    end select
  end function to_long_vect

  !> Equal.
  elemental module logical function eq(val1, val2)
    type(long_integer), intent(in) :: val1, val2

    eq = all(val1%digit == val2%digit) &
         .and. val1%sign == val2%sign
  end function eq

  !> Greater than
  elemental module logical function gt(val1, val2)
    type(long_integer), intent(in) :: val1, val2
    logical :: pstv, ngtv
    integer(i32) :: c

    c = comp_(val1%digit, val2%digit)
    pstv = all([val1%sign, val2%sign] == "+")
    ngtv = all([val1%sign, val2%sign] == "-")
    gt = any([pstv .and. c == 1, ngtv .and. c == -1, &
      val1%sign == "+" .and. val2%sign == "-"])
  end function gt

  !> Less than
  elemental module logical function lt(val1, val2)
    type(long_integer), intent(in) :: val1, val2
    logical :: pstv, ngtv
    integer(i32) :: c

    c = comp_(val1%digit, val2%digit)
    pstv = all([val1%sign, val2%sign] == "+")
    ngtv = all([val1%sign, val2%sign] == "-")
    lt = any([pstv .and. c == -1, ngtv .and. c == 1, &
      val1%sign == "-" .and. val2%sign == "+"])
  end function lt

  !> Greater than or equal to.
  elemental module logical function ge(val1, val2)
    type(long_integer), intent(in) :: val1, val2

    ge = gt(val1, val2) .or. eq(val1, val2)
  end function ge

  !> Less than or equal to
  elemental module logical function le(val1, val2)
    type(long_integer), intent(in) :: val1, val2

    le = lt(val1, val2) .or. eq(val1, val2)
  end function le

  #: for func in rel_funcs
  #: for suffix, declare in list(zip(suffixes, declares))
  !> Wrapper of function ${func}$ for type ${declare}$
  pure module function ${func}$_${suffix}$ (val1, val2) result(ret)
    type(long_integer), intent(in) :: val1
    ${declare}$, intent(in) :: val2
    logical :: ret

    ret = ${func}$ (val1, int(val2, "ll"))
  end function ${func}$_${suffix}$${"\n"}$
  #: endfor
  #: endfor

  !> Addition.
  elemental module function add(val1, val2) result(ret)
    type(long_integer), intent(in) :: val1, val2
    type(long_integer) :: ret
    integer(i32) :: c

    associate ( &
      dig1 => val1%digit, &
      dig2 => val2%digit, &
      sgn1 => val1%sign, &
      sgn2 => val2%sign)

      c = comp_(dig1, dig2)
      if (sgn1 == sgn2) then
        ret%digit = add_(dig1, dig2)
        ret%sign = sgn1
      else
        if (c == 0) then
          ret = 0
          return
        end if

        ret%digit = merge( &
          sub_(dig1, dig2), &
          sub_(dig2, dig1), c == 1)

        ret%sign = merge( &
          sgn1, sgn2, sgn1 == "+")
      end if
    end associate
  end function add

  !> Opposite number (additive inverse)
  elemental function opposite(val) result(ret)
    type(long_integer), intent(in) :: val
    type(long_integer) :: ret

    ret%digit = val%digit
    ret%sign = merge("+", "-", val%sign == "-")
  end function opposite

  !> Subtraction.
  elemental module function sub(val1, val2) result(ret)
    type(long_integer), intent(in) :: val1, val2
    type(long_integer) :: ret

    ret = val1 + opposite(val2)
  end function sub

  !> Multiplication
  elemental module function mul(val1, val2) result(ret)
    type(long_integer), intent(in) :: val1, val2
    type(long_integer) :: ret

    ret%sign = merge("+", "-", val1%sign == val2%sign)
    ret%digit = mul_(val1%digit, val2%digit)
  end function mul

  !> Power
  elemental recursive module function pow(val1, val2) result(ret)
    type(long_integer), intent(in) :: val1
    integer(i32), intent(in) :: val2
    type(long_integer) :: ret

    if (val2 < 0) then
      error stop ""
    else if (val2 == 0) then
      ret = 1
    else if (mod(val2, 2) == 0) then
      ret = pow(val1*val1, val2/2)
    else if (mod(val2, 2) /= 0) then
      ret = val1*pow(val1*val1, (val2 - 1)/2)
    end if
  end function pow

  #: for func in ['add', 'sub', 'mul']
  #: for suffix, declare in list(zip(suffixes, declares))
  !> Wrapper of function ${func}$ for type ${declare}$
  pure module function ${func}$_${suffix}$ (val1, val2) result(ret)
    type(long_integer), intent(in) :: val1
    ${declare}$, intent(in) :: val2
    type(long_integer) :: ret

    ret = ${func}$ (val1, int(val2, "ll"))
  end function ${func}$_${suffix}$${"\n"}$
  #: endfor
  #: endfor

end submodule multiprecision_submodule
