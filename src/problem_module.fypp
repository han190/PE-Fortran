module problem_module

  use interface_module
  implicit none

  type :: problem_type
    procedure(problem_x), nopass, pointer :: answer => null()
  end type problem_type

  abstract interface
    character(len=20) function problem_x()
    end function problem_x
  end interface

contains

  subroutine initialize_problems(problems)
    type(problem_type), allocatable, intent(inout) :: problems(:)

    allocate (problems(${NUM_PROB}$))
    #: for i in range(1, NUM_PROB + 1)
    problems(${i}$)%answer => euler${"%4.4d" % (i,)}$
    #: endfor
  end subroutine initialize_problems

end module problem_module
